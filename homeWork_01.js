// Занятие 2 - Сети, JS (Типы данных, приведение типов)

// Домашнее занятие
//К 3 встрече (11.09) подготовить по 2 вопроса на пройденные темы.

// Каким образом мы можем использовать методы для строк и чисел, ведь это примитивы?
// Когда HTTP вызов считается идемпотентным?
// Придумать аналогию для http из повседневного мира
// Какой тип у null? почему?
// console.log('MAX_SAFE_INTEGER: ' + Number.MAX_SAFE_INTEGER) // 10(в 53 степени) - 1

//Для выполнения задания создаем новую ветку в вашем репозитории с именованием - homeWork_01, после выполнения д/з - прикрепляем ссылку к сдаче задания.

// 1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

// Когда клиент отправляет запрос OPTIONS, сервер отвечает списком методов (как GET, POST, PUT, DELETE и другие), которые можно использовать для работы с этим ресурсом. Таким образом, OPTIONS помогает клиенту понять, какие операции разрешены для данного ресурса, и какие запросы можно отправлять серверу.
// Этот метод полезен, например, для проверки разрешений на кросс-доменные запросы (CORS), когда веб-страница на одном домене хочет обращаться к ресурсам на другом домене. Он также может использоваться для определения доступных функциональных возможностей API.

// 2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0

// Использование транспортного протокола QUIC: QUIC (Quick UDP Internet Connections) - обеспечивает более эффективную передачу данных по сравнению с TCP, используемым HTTP/2. QUIC использует UDP, который является более легким протоколом, чем TCP, и может передавать данные более эффективно, особенно в сетях с потерями пакетов.
// Шифрование по умолчанию: HTTP/3 использует шифрование по умолчанию, что обеспечивает более высокий уровень безопасности, чем HTTP/2. Это помогает защитить данные от перехвата и анализа.
// Оптимизация для мобильных устройств: HTTP/3 оптимизирован для мобильных устройств, что позволяет обеспечить более высокую скорость и производительность на устройствах с ограниченными ресурсами.

// 3) Прочитать про способы отмены запроса, включая объект "AbortController"

// 3) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

// const string1 = 'str1'
// const string2 = String(123)
// const string3 = 123..toString()
// const string4 = 123 + ''

// const number1 = 0
// const number2 = Number('123')
// const number3 = parseInt('123')
// const number4 = parseFloat('123.123')
// const number5 = +'123'
// const number6 = 1 - '123'
// const number7 = '1' & '123'

// const isTrue1 = Boolean(true)
// const isTrue2 = 3 == "3"
// const isTrue3 = !!0
// const isTrue4: if (isTrue) {...}

// let emptyValue1 = null
// let notEmptyValue = 1
// function getNull(variable) {
//     return variable = null
// }
// const emptyValue2 = getNull(notEmptyValue)

// let notInitializedVar1
// const emptyObj = {}
// let notInitializedObjKey = emptyObj.anyKey

// const emptySymbol = Symbol()
// const symbolWithDescription = Symbol('symbol description')

// const negativeTinyBigInt = -120n
// const bigIntFromString = BigInt("1234567890")

// 4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?

//  При всплытии попадают в мёртвую зону.

//    5) Решить:

    const res = "B" + "a" + (1 - "hello");
console.log(res); // BaNaN

const res2 = (true && 3) + "d";
console.log(res2); // "3d"

const res3 = Boolean(true && 3) + "d";
console.log(res3); // "trued"
